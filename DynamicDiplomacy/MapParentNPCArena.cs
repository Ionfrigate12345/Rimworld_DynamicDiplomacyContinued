using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using RimWorld;
using RimWorld.Planet;
using UnityEngine;
using Verse;

namespace DynamicDiplomacy
{
    internal class MapParentNPCArena : MapParent
    {
        public List<Pawn> lhs = new List<Pawn>();

        public List<Pawn> rhs = new List<Pawn>();

        public Faction attackerFaction;

        public Faction defenderFaction;

        public Settlement combatLoc;

        public int tickCreated;

        public int tickFightStarted;

        public bool isCombatEnded = false;

        public string customLabel;

        public string customDescription;

        private const int TICK_TIMEOUT = GenDate.TicksPerDay * 2;

        public override string Label
        {
            get
            {
                return customLabel ?? base.Label;
            }
        }

        public override string GetDescription()
        {
            return customDescription ?? base.GetDescription();
        }

        public override string GetInspectString()
        {
            return base.GetInspectString() + "\n" + attackerFaction.Name + " VS " + defenderFaction.Name;
        }

        public MapParentNPCArena() : base()
        {
            
        }

        private static bool HasAnyOtherBase(Settlement defeatedFactionBase)
        {
            List<Settlement> settlements = Find.WorldObjects.Settlements;
            for (int i = 0; i < settlements.Count; i++)
            {
                Settlement settlement = settlements[i];
                if (settlement.Faction == defeatedFactionBase.Faction)
                {
                    return true;
                }
            }
            return false;
        }

        public override void Tick()
        {
            var tickCount = Find.TickManager.TicksGame;

            //Ionfrigate12345 added in 1.5: Avoid running this script every tick, which is performance consuming.
            if (tickCount % 60 != 0)
            {
                return;
            }

            if (isCombatEnded)
            {
                if (this.HasMap && Map.mapPawns.PawnsInFaction(Faction.OfPlayer).Count() == 0)
                {
                    Log.Message("[Dynamic Diplomacy] Fight end between " + attackerFaction.Name + " and " + defenderFaction.Name + " for settlement " + combatLoc.Name + ". " + "Removing arena...");
                    Find.WorldObjects.Remove(this);
                }
                else if (!this.HasMap)
                {
                    Log.Message("[Dynamic Diplomacy] battle sim not started between " + attackerFaction.Name + " and " + defenderFaction.Name + " for settlement " + combatLoc.Name + ". " + " The player didnt arrive before timeout. Removing arena...");
                    Find.WorldObjects.Remove(this);
                }
                return;
            }

            IncidentWorker_NPCConquest.UpdateSettingParameters();
            if (IncidentWorker_NPCConquest.usingSemiSimulation) //Ionfrigate12345 added in 1.5: semi sim mode.Sim battle only with player presence.
            {
                if (!this.HasMap && Find.TickManager.TicksGame - this.tickCreated > TICK_TIMEOUT)
                {
                    // In semi-simulation mode, timeout means the fight has started but the player exited the map.
                    isCombatEnded = true;
                    OnTimeOut();
                    return;
                }

                if (this.tickFightStarted == 0)
                {
                    //If this tile already has a map, usually generated by another mod (like SOS2 shuttle) before this mod does the same, in this case use directly this map as battle arena and start immediately battle sim.
                    List<Map> otherMapsOnSameTile = Find.Maps.Where(m => m.Parent.Tile == this.Tile).ToList();
                    if (otherMapsOnSameTile.Count() > 0)
                    {
                        var otherMap = otherMapsOnSameTile.First();
                        otherMap.info.parent = this;
                        IncidentWorker_NPCConquest.InitArenaMap(
                                this,
                                attackerFaction,
                                defenderFaction,
                                combatLoc,
                                IncidentWorker_NPCConquest.GenerateFactionNPCGroup(attackerFaction, IncidentWorker_NPCConquest.simulatedConquestThreatPoint),
                                IncidentWorker_NPCConquest.GenerateFactionNPCGroup(defenderFaction, IncidentWorker_NPCConquest.simulatedConquestThreatPoint),
                                true,
                                otherMap
                            );
                    }
                }

                if (!this.HasMap && this.tickFightStarted == 0)
                {
                    // Check if any player caravan has reached the site. If so, generate the map.
                    var playerCaravanPawns = PawnsFinder.AllCaravansAndTravelingTransportPods_Alive.Where(p => p.Faction == Faction.OfPlayer).ToList();
                    foreach (var playerCaravanPawn in playerCaravanPawns)
                    {
                        var playerCaravan = playerCaravanPawn.GetCaravan();
                        if (playerCaravan == null)
                        {
                            continue;
                        }
                        if (playerCaravan.Tile == this.Tile)
                        {
                            // need to wait till map generated (player pawns arrived)
                            IncidentWorker_NPCConquest.InitArenaMap(
                                this,
                                attackerFaction,
                                defenderFaction,
                                combatLoc,
                                IncidentWorker_NPCConquest.GenerateFactionNPCGroup(attackerFaction, IncidentWorker_NPCConquest.simulatedConquestThreatPoint),
                                IncidentWorker_NPCConquest.GenerateFactionNPCGroup(defenderFaction, IncidentWorker_NPCConquest.simulatedConquestThreatPoint),
                                true
                            );
                            //StartTheFight();
                            break;
                        }
                    }
                }
            }
            else
            {
                if ((this.tickFightStarted == 0 && Find.TickManager.TicksGame - this.tickCreated > 10000) || (this.tickFightStarted != 0 && Find.TickManager.TicksGame - this.tickFightStarted > TICK_TIMEOUT))
                {
                    isCombatEnded = true;
                    OnTimeOut();
                    return;
                }
                /*if (this.tickFightStarted == 0)
                {
                    StartTheFight();
                }*/
            }
            if (this.tickFightStarted != 0)
            {
                if (this.lhs == null || this.rhs == null)
                {
                    Log.Warning("[Dynamic Diplomacy] Conquest simulation improperly set up!");
                    Find.WorldObjects.Remove(this);
                    return;
                }
                if (!attackerFaction.HostileTo(defenderFaction))
                {
                    FactionRelation factionRelation = attackerFaction.RelationWith(defenderFaction, false);
                    factionRelation.kind = FactionRelationKind.Hostile;
                }

                bool flag = !this.lhs.Any(pawn => pawn != null && !pawn.Dead && !pawn.Downed && pawn.Spawned);
                bool flag2 = !this.rhs.Any(pawn => pawn != null && !pawn.Dead && !pawn.Downed && pawn.Spawned);
                if (flag || flag2)
                {
                    if (flag && !flag2)
                    {
                        OnDefenderWin();
                    }
                    else
                    {
                        OnAttackerWin();
                    }
                    if (this.HasMap && Map.mapPawns.PawnsInFaction(Faction.OfPlayer).Count() == 0)
                    {
                        //Clear npc pawns if no player pawn present.
                        foreach (Pawn current2 in this.lhs.Concat(this.rhs))
                        {
                            if (current2 != null && current2.Destroyed == false)
                            {
                                current2.Destroy(DestroyMode.Vanish);
                            }
                        }
                    }
                    isCombatEnded = true;

                    //If player pawns are present, force reform
                    /*if(this.ParentHasMap && (parent as MapParent).Map.mapPawns.PawnsInFaction(Faction.OfPlayer).Count() > 0)
                    {
                        ForceReform();
                    }
                    Find.WorldObjects.Remove(this.parent);*/

                    /*if(IncidentWorker_NPCConquest.usingSemiSimulation == false || this.ParentHasMap && (parent as MapParent).Map.mapPawns.PawnsInFaction(Faction.OfPlayer).Count() == 0)
                    {
                        Find.WorldObjects.Remove(this.parent);
                    }*/

                    Log.Message("[Dynamic Diplomacy] battle switch flipped");
                }
            }
        }

        private void OnDefenderWin()
        {
            Log.Message("[Dynamic Diplomacy] battle sim defender wins");
            Find.LetterStack.ReceiveLetter("LabelConquestBattleDefended".Translate(), "DescConquestBattleDefended".Translate(defenderFaction.Name, combatLoc.Name, attackerFaction.Name), LetterDefOf.NeutralEvent, combatLoc, attackerFaction);
        }

        private void OnAttackerWin()
        {
            // Determine whether to raze or take control, random-based
            int razeroll = Rand.Range(1, 100);
            if (razeroll <= IncidentWorker_NPCConquest.razeChance)
            {
                OnAttackerWinRaze();
            }
            else
            {
                OnAttackerWinConquest();
            }
            DefeatCheck();
        }

        private void OnAttackerWinConquest()
        {
            Log.Message("[Dynamic Diplomacy] battle sim attacker wins conquest");
            Settlement settlement = (Settlement)WorldObjectMaker.MakeWorldObject(WorldObjectDefOf.Settlement);
            settlement.SetFaction(attackerFaction);
            settlement.Tile = combatLoc.Tile;
            settlement.Name = SettlementNameGenerator.GenerateSettlementName(settlement, null);
            Find.WorldObjects.Remove(combatLoc);
            Find.WorldObjects.Add(settlement);
            Find.LetterStack.ReceiveLetter("LabelConquest".Translate(), "DescConquest".Translate(defenderFaction.Name, settlement.Name, settlement.Faction.Name), LetterDefOf.NeutralEvent, settlement, attackerFaction);
        }

        private void OnAttackerWinRaze()
        {
            Log.Message("[Dynamic Diplomacy] battle sim attacker wins raze");
            if (IncidentWorker_NPCConquest.allowRazeClear)
            {
                List<DestroyedSettlement> clearRuinTarget = Find.WorldObjects.DestroyedSettlements;
                for (int i = 0; i < clearRuinTarget.Count; i++)
                {
                    Find.WorldObjects.Remove(clearRuinTarget[i]);
                }
            }

            DestroyedSettlement destroyedSettlement = (DestroyedSettlement)WorldObjectMaker.MakeWorldObject(WorldObjectDefOf.DestroyedSettlement);
            destroyedSettlement.Tile = combatLoc.Tile;
            Find.WorldObjects.Remove(combatLoc);
            Find.WorldObjects.Add(destroyedSettlement);
            Find.LetterStack.ReceiveLetter("LabelConquestRaze".Translate(), "DescConquestRaze".Translate(attackerFaction.Name, defenderFaction.Name), LetterDefOf.NeutralEvent, destroyedSettlement, attackerFaction);
            ExpandableWorldObjectsUtility.ExpandableWorldObjectsUpdate();
        }

        private void OnTimeOut()
        {
            var winner = UtilsAutoCombatCalculator.GetAutoBattleWinner(attackerFaction, defenderFaction);
            if(winner == attackerFaction)
            {
                OnAttackerWin();
            }
            else
            {
                OnDefenderWin();
            }
            Log.Message("[Dynamic Diplomacy] Fight timed out or player never joined the battle. Result randomly decided.");
        }

        public void StartTheFight()
        {
            /*foreach (Pawn current in this.lhs.Concat(this.rhs))
            {
                if (current.records.GetValue(RecordDefOf.ShotsFired) > 0f || (current.CurJob != null && current.CurJob.def == JobDefOf.AttackMelee && current.Position.DistanceTo(current.CurJob.targetA.Thing.Position) <= 2f))
                {
                    Log.Message("[Dynamic Diplomacy] Fight started between " + attackerFaction.Name + " and " + defenderFaction.Name + " for settlement " + combatLoc.Name);
                    this.tickFightStarted = Find.TickManager.TicksGame;
                    break;
                }
            }*/
            Log.Message("[Dynamic Diplomacy] Fight started between " + attackerFaction.Name + " and " + defenderFaction.Name + " for settlement " + combatLoc.Name);
            this.tickFightStarted = Find.TickManager.TicksGame;
        }

        private void DefeatCheck()
        {
            // Defeat check for random conquest
            if (IncidentWorker_NPCConquest.allowCloneFaction && !HasAnyOtherBase(combatLoc))
            {
                List<Faction> clonefactioncheck = (from x in Find.FactionManager.AllFactionsVisible
                                                   where !x.def.hidden && !x.IsPlayer && !x.defeated && x != defenderFaction && x.def == defenderFaction.def
                                                   select x).ToList<Faction>();
                if (clonefactioncheck.Count > 0)
                {
                    defenderFaction.defeated = true;
                    Find.LetterStack.ReceiveLetter("LetterLabelFactionBaseDefeated".Translate(), "LetterFactionBaseDefeated_FactionDestroyed".Translate(defenderFaction.Name), LetterDefOf.NeutralEvent);
                }
            }

            int defeatroll = Rand.Range(1, 100);
            if (defeatroll <= IncidentWorker_NPCConquest.defeatChance && !HasAnyOtherBase(combatLoc))
            {
                defenderFaction.defeated = true;
                Find.LetterStack.ReceiveLetter("LetterLabelFactionBaseDefeated".Translate(), "LetterFactionBaseDefeated_FactionDestroyed".Translate(defenderFaction.Name), LetterDefOf.NeutralEvent);
            }
        }

        public override void ExposeData()
        {
            base.ExposeData();

            Scribe_References.Look(ref attackerFaction, "DynamicDiplomacy_DebugArena_attackerFaction", false);
            Scribe_References.Look(ref defenderFaction, "DynamicDiplomacy_DebugArena_defenderFaction", false);
            Scribe_References.Look(ref combatLoc, "DynamicDiplomacy_DebugArena_combatLoc", true);
            Scribe_Values.Look(ref tickCreated, "DynamicDiplomacy_DebugArena_tickCreated", 0);
            Scribe_Values.Look(ref tickFightStarted, "DynamicDiplomacy_DebugArena_tickFightStarted", 0);
            Scribe_Values.Look(ref isCombatEnded, "DynamicDiplomacy_DebugArena_isCombatEnded", false);
            Scribe_Values.Look(ref customLabel, "DynamicDiplomacy_DebugArena_customLabel", "");
            Scribe_Values.Look(ref customDescription, "DynamicDiplomacy_DebugArena_customDescription", "");
            Scribe_Collections.Look(ref lhs, "DynamicDiplomacy_DebugArena_lhs", LookMode.Reference);
            Scribe_Collections.Look(ref rhs, "DynamicDiplomacy_DebugArena_rhs", LookMode.Reference);
        }
    }
}
